# Python или Ruby? Госпади спаси!

[Makefile](#makefile) - Зачем и как создать нормальный Makefile



## Makefile  

Для компиляции любого приложения с более чем одним файлом с исхожным кодом, нужно описать сценарий сборки.  
Библиотеки, объекты, пути и прочее.  
Для этого нужно составлять так называемый Makefile.  
При наличии данного файла в директории, для сборки приложения достаточно набрать команду `make` и прилодение соберется самостоятельно по описаннуму сценарию сборки.  

```make
MyProject : main.o my_lib.o
    gcc main.o my_lib.o -o MyProject

main.o : main.c
    gcc -c main.c -o main.o

my_lib.o : my_lib.c
    gcc -c my_lib.c -o my_lib.o

clean : 
    rm MyProject *.o
```

__MyProject__ - исполняемый файл приложения. Для его сборки трубуются скомпилированные объекты main.o и my_lib.o.  
__main.o__ - правило компиляции для файла main.c  
__my_lib.o__ - правило компиляции для файла my_lib.c  
__clean__ - доп правило которое удаляем исполняемый файл и ранее созданные объекты. Она требуется для полной пересборки проекта. Без нее будут пересобиратся только те файлы, в которые ранее были внесены изменения.

Соотвественно `make clean` - очистит проект, а следом `make` соберет проект с нуля. 

Далее начинаем упрощать данный файл.  

Используя переменные можно упростить дальнейшую коректировку правил, меня только один раз значение переменной. 

```make
TARGET = MyProject
CC = gcc

$(TARGET) : main.o my_lib.o
    $(CC) main.o my_lib.o -o $(TARGET)

main.o : main.c
    $(CC) -c main.c -o main.o

my_lib.o : my_lib.c
    $(CC) -c my_lib.c -o my_lib.o

clean : 
    rm $(TARGET) *.o
```

Дале определим группы файлов виде переменных 

Получить список всех файлов с исходным текстом программы (всех файлов с расширением ".cpp"). Для этого можно использовать функцию `wildcard`.  
Преобразовать список исходных файлов в список объектных файлов (заменить расширение ".cpp" на расширение ".o"). Для этого можно воспользоваться функцией `patsubst`.  
`SRC = $(wildcard *.c)` - все исходники   
`OBJ = $(patsubst %.c, %.o, $(SRC))` - все объекты. Так как объекты появляются только после компиляции, мы возьмем все измена исходников и составим из них именя будущийх объетов.   
  
| Автоматическая переменная | Назначение | 
| :----|---|
|$@| Имя файла цели правила. В шаблонном правиле с несколькими целями,имя той цели, которая вызвала выполнение команд правила.|
|$<| Имя первой зависимости. Если цель получила свои команды из неявного правила, то это будет первая зависимость, добавленная неявным правилом.
|$?| Имена всех зависимостей, которые являются более новыми, чем цель, с  пробелами между ними. | 
|$^| Имена всех зависимостей, с пробелами между ними. Если Вы для цели неоднократно укажете одну и ту же зависимость, значение переменной '$^' будет содержать только одну копию ее имени. |
|$+| Эта переменная аналогична переменной '$^', только зависимости, указанные неоднократно дублируются в том порядке, в котором они указаны в make-файле. Это в первую очередь полезно для использования в командах компоновки, где является существенным повторение имен библиотек в определенном порядке  |
|$*| База с которой сопоставляется неявное правило (см. ниже). В шаблонном правиле база представляет собой часть имени файла, которая сопоставляется символу '%' в шаблоне цели. Если целью является файл 'dir/a.foo.b', а   шаблон цели - 'a.%.b', то базой будет 'dir/foo'. База полезна для создания имен файлов, связанных с правилом. В явных правилах база не определена как имя файла без расширения,если такое расширение можно выделить. Не рекомендуется использовать эту переменную в явных правилах |




```make
TARGET = MyProject
CC = gcc

SRC = $(wildcard *.c)
OBJ = $(patsubst %.c, %.o, $(SRC))

${TARGET} : $(OBJ)
    $(CC) $(OBJ) -o $(TARGET)

%.o : %.c
    $(CC) -c $< $@

clean : 
    rm (TARGET) *.o
```

И для порлной красоты разнесем все по папкам.  
Исходники все будут лежать в тапке ./src/  
Объекты в папке ./obj/  
Исполняемые файлы в папке ./build/

```make
TARGET = MyProject
CC = gcc

PREF_SRC = ./src/
PREF_OBJ = ./obj/
PREF_TARGET = ./build/

SRC = $(wildcard $(PREF_SRC)*.c)
OBJ = $(patsubst $(PREF_SRC)%.c, $(PREF_OBJ)%.o, $(SRC))

$(PREF_TARGET)$(TARGET) : $(OBJ)
    $(CC) $(OBJ) -o $(TARGET)

$(PREF_OBJ)%.o : $(PREF_SRC)%.c
    $(CC) -c $< $@

clean : 
    rm $(TARGET) $(PREF_OBJ)*.o
```

